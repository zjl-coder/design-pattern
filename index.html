<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
    <style>
      a {
        text-decoration: none;
      }
    </style>
  </head>
  <body>
    <h1>工程化</h1>
    <ul>
      <li>自动测试</li>
      <li>持续继承</li>
      <li>持续发行流程</li>
    </ul>
    <h1>SOLID五大设计原则</h1>
    <ul>
      <li>S - 单一职责原则</li>
      <li>O - 开放封闭原则</li>
      <li>L -里氏替换原则</li>
      <li>I - 接口分离原则</li>
      <li>D - 依赖倒置原则</li>
    </ul>
    <h1>es6 23种设计模式</h1>
    <h4>创建型 (创建对象实例)</h4>
    <ul>
      <a href="./1-单例模式/index.html">1、单例模式 / 单体模式</a> <br />
      <a href="./2-工厂模式/index.html">2、工厂模式</a> <br />
      <a href="./3-抽象工厂模式/index.html">3、抽象工厂模式</a> <br />
      <a href="./4-建造者模式/index.html">4、建造者模式 / 生成器模式</a> <br />
      <a href="./5-原型模式/index.html">5、原型模式</a>（继承） <br />
    </ul>
    <h4>结构型</h4>
    <ul>
      <a href="./6-适配器模式/index.html">6、适配器模式 / 包装器模式</a> <br />
      <a href="./7-桥接模式/index.html">7、桥接模式 / 桥梁模式</a>（建造者模式简化版，一步到位）<br />
      <a href="./8-代理模式/index.html">8、代理模式 / 委托模式</a> （插在目标对象和访问者之间，起到对目标对象的访问权限，或者拓展功能等，如 老板、秘书、访客，秘书为老板筛选访问者，或者处理一些老板不需要处理的事情）<br />
      <a href="./9-装饰者模式/index.html">9、装饰者模式 / 装饰器模式</a>（代理模式的简化版，只添加新功能，没有权限控制，只要访问，就一定能访问到目标对象） <br />
      <a href="./10-外观模式/index.html">10、外观模式 / 门面模式</a>（函数重载，简化调用，不推荐新增功能，有可能会变成装饰器模式 ）<br />
      <a href="./11-组合模式/index.html">11、组合模式 / 整体--部分模式</a>（将对象组合成树形结构来表现整体-部分层次结构，天生实现了职责链模式）<br />
      <a href="./12-享元模式/index.html">12、享元模式</a> （创建池子，共享对象放入池子，有空闲对象就取来用，高级的享元模式还加上了发布订阅模式，没有就等待，有空闲就发出通知）<br />
    </ul>
    <h4>行为型</h4>
    <ul>
      <a href="./13-观察者模式/index.html">13、观察者模式 / 发布--订阅模式</a> <br />
      <a href="./14-模板模式/index.html">14、模板模式</a> （抽象类 继承实现，与抽象工厂的区别在于工厂可能产生不同对象，如苹果对象，梨对象）<br />
      <a href="./15-策略模式/index.html">15、策略模式 / 政策模式</a> （一个调用入口，根据参数不同，调用不同的函数算法，算法的行为是类似的，维护在map里面，可以动态添加新的算法到map里面，有点是可以一定程度上规避if判断，直接根据参数从map中动态获取算法）<br />
      <a href="./16-职责链模式/index.html">16、职责链模式</a> （每个函数独立功能，并且互相之间能够组成上下游关系，比如 a.setNext(b), 则当a无法满足条件时，自动调用b进行处理，天然是单节点的层级树【链】）<br />
      <a href="./17-状态模式/index.html">17、状态模式</a> （在构造函数内部维护一个私有变量，当变量值改变时，调用同样的接口，得到的行为不同）<br />
      <a href="./18-迭代器模式/index.html">18、迭代器模式</a> （使用者不需要关心对象的内部构造，就可以按序访问其中的每个元素。javascript 已提供了很多迭代器，不需要自己实现了，比如 Array 上的 filter、forEach、reduce、flat 等，具有 Symbol.iterator 属性就可以用 for...of 循环遍历它的成员）<br />
      <a href="./19-访问者模式/index.html">19、访问者模式</a> （当目标类A的使用者不同，如 男人，女人，a.setUser('男')，a.readPaper()得到的结果不同，内部实现是根据不同的user实例，返回不同的结果）<br />
      <a href="./20-备忘录模式/index.html">20、备忘录模式</a> （A是调用者，B是需要备完的目标，C是持久化队列，a实例 从 b实例 获取内部状态，然后存在C队列上，下次a先从C获取属于b的记录，然后调用new B('数据')，或者setXXX 还原b之前的状态，不一定是同一个对象，但是一定状态相同）<br />
      <a href="./21-命令模式/index.html">21、命令模式 / 事务模式</a> （属性和行为分开独立封装Ab、Ac，通过调用Ac方法实际上改变Ab的属性，Ab拥有自己的方法和属性，Ac只拥有可以控制Ab属性或方法的方法，很少使用，一般行为属性都封装在一起）<br />
      <a href="./22-解释器模式/index.html">22、解释器模式</a> （解释某些特殊语法的函数，比如封装一个逆波兰算法，或则传入一个“1+1-1”的字符串，能够以数字进行运算，得出结果。需要区分算法中的终结符【确认结果的符号】和非终结符【等待确认，或则不表示结果的符号，+-*/等，或者【R1=1、R2=2、R3=R1+R2】R1,R2为终结符，R3为非终结符】）<br />
      <a href="./23-中介者模式/index.html">23、中介模式</a> （降低多个对象和类之间的通信复杂性，比如，100个购房者在无中介的情况下要看50个楼盘，会形成复杂的轨迹，引入中介后，100个购房者只需要通过中介即可获取100个楼盘的信息，中介负责收集和销售这100个楼盘，简化楼盘的买卖，与代理模式的区别在于代理背后只有一个对象，而中介背后有多个对象）<br />
    </ul>
    <h4>其他型</h4>
    <ul>
      <a href="./24-MVC-MVP-MVVM/index.html">24、MVC、MVP、MVVM</a> （【MVC，M只关心如何操作数据，V监听M的行为，并更新界面，C接收来自V的事件，并调用M更新数据,同时M通知V更新界面】【MVP，V不监听M,改为监听C,C接收事件调用M修改数据，并得到M的返回结果，然后C通知V更新界面，V与M不再有联系】【MVVM，将P改为VM，V和VM互为订阅者和发布者，当V有变化时，通知VM调用M更新数据，当M结果返回是，通知VM通知V更新界面，而MVP下则V在数据变化时，需要开发者自己通过事件通知P，MVVM则VM已经在V的事件onInput中注册了监听，开发者大多数情况下可以不用自定义事件通知VM】【vue是MVVM,react 非严格上的mvvm，更像mvp】）<br />
      <a href="./25-模块模式/index.html">25、模块模式</a> (闭包，ES6 module，CommonJS、AMD、CMD)<br />
      <a href="./26-链模式/index.html">26、链模式</a> （链式调用）<br />
      <a href="./27-中间件/index.html">27、中间件</a> （express 单向管道模型，koa的洋葱模型，定义好规范之后注册的中间接接收到参数都是一样的规范，然后处理之后将参数传给下一个中间件）<br />
    </ul>
    <h4>创建型演变</h4>
    <div><strong>工厂模式</strong> 将工厂抽象使得工厂类可继承产生子工厂演变成 <strong>抽象工厂模式</strong> ,工厂模式创建对象的过程需要一个使用者一步一步的指挥（调用相关函数）演变成 <strong>建造者模式</strong></div>
  </body>
</html>
